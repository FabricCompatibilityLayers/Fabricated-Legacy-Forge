/*
 * The FML Forge Mod Loader suite.
 * Copyright (C) 2012 cpw
 *
 * This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */
package cpw.mods.fml.common;

import argo.jdom.JdomParser;
import argo.jdom.JsonNode;
import argo.jdom.JsonRootNode;
import argo.saj.InvalidSyntaxException;
import com.google.common.base.Throwables;
import com.google.common.collect.Maps;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Iterator;
import java.util.Map;
import java.util.logging.Level;

public class MetadataCollection {
    private static JdomParser parser = new JdomParser();
    private Map<String, ModMetadata> metadatas = Maps.newHashMap();
    private int metadataVersion = 1;

    public MetadataCollection() {
    }

    public static MetadataCollection from(InputStream inputStream, String sourceName) {
        if (inputStream == null) {
            return new MetadataCollection();
        } else {
            InputStreamReader reader = new InputStreamReader(inputStream);

            try {
                JsonRootNode root = parser.parse(reader);
                return root.hasElements() ? parse10ModInfo(root) : parseModInfo(root);
            } catch (InvalidSyntaxException var4) {
                FMLLog.log(Level.SEVERE, var4, "The mcmod.info file in %s cannot be parsed as valid JSON. It will be ignored", new Object[]{sourceName});
                return new MetadataCollection();
            } catch (Exception var5) {
                throw Throwables.propagate(var5);
            }
        }
    }

    private static MetadataCollection parseModInfo(JsonRootNode root) {
        MetadataCollection mc = new MetadataCollection();
        mc.metadataVersion = Integer.parseInt(root.getNumberValue(new Object[]{"modinfoversion"}));
        mc.parseModMetadataList(root.getNode(new Object[]{"modlist"}));
        return mc;
    }

    private static MetadataCollection parse10ModInfo(JsonRootNode root) {
        MetadataCollection mc = new MetadataCollection();
        mc.parseModMetadataList(root);
        return mc;
    }

    private void parseModMetadataList(JsonNode metadataList) {
        for(JsonNode node : metadataList.getElements()) {
            ModMetadata mmd = new ModMetadata(node);
            this.metadatas.put(mmd.modId, mmd);
        }
    }

    public ModMetadata getMetadataForId(String modId, Map<String, Object> extraData) {
        if (!this.metadatas.containsKey(modId)) {
            ModMetadata dummy = new ModMetadata();
            dummy.modId = modId;
            dummy.name = (String)extraData.get("name");
            dummy.version = (String)extraData.get("version");
            dummy.autogenerated = true;
            this.metadatas.put(modId, dummy);
        }

        return (ModMetadata)this.metadatas.get(modId);
    }
}
